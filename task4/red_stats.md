# Архитектура сервиса RED_STATS


### Вводные

Определим характер нагрузки.

Так как сервис RED стал популярным, то пусть у него будет нагрузка в 500 rps, поэтому из RED в RED_STATS нагрузка будет аналогичной.
Причем из условий понятно, что превышение порога красного цвета это событие, о котором стоит оповещать, поэтому предположим, что 
500 rps это 100 клиентов, каждый из которых грузит по 5 картинок в секунду.

Хранить данные RED_STATS будет в следующих pg-таблицах:

_red_stats_table_ :
- id - INT - идентификатор записи
- user_id - VARCHAR - идентификатор пользователя(uuid4)
- timestamp - TIMESTAMP - время события в UTC
- red_percentage - FLOAT - процент красного от 0 до 1

мультиколоночный индекс на user_id+timestamp

_subscription_table_ :
- id - INT - идентификатор записи
- user_id - VARCHAR - идентификатор пользователя(uuid4)
- calback_url - VARCHAR - url, предоставленный клиентом, по которому нужно сообщить о новом сообщении заданного порога
- calback_headers - JSON - опциональное поле с заголовками от клиента, для отправки запроса ему
- subscribe_threshold - FLOAT - процент красного, при превышении которого нужно сообщать клиенту

индекс на user_id


### RED_STATS API

__Авторизация__ Для простоты пусть авторизация будет происходить по токену, расположенному в заголовке `Auth`. Этот токен будет выдаваться клиенту отдельно.


`POST red_stats_url/subsribe`
Тело:
```
{
  "callback_headers": <>,
  "callback_url": <url>,
  "subscribe_threshold": <0..1>,
}
```
Эти данные будут записаны в таблицу _subscription_table_.

`POST red_stats_url/unsubscribe`
Запрос на случай, если клиент захочет отказаться от оповещений. По токену определяем клиента и удаляем запись из _subscription_table_


`GET red_stats_url/get_stats?start_datetime=...&end_datetime=...&red_threshold=...`
Ручка для ручного получения информации пользователем.
Ответ в формате:
```
{
  "total_images_cnt": <int>, # сколько всего было изображений за указанный период
  "thresholded_images_cnt": <int> # сколько было изображений выше заданного порога за указанный период
}
```
datetime-аргументы задают полуинтервал фильтрации, каждый из них не обязателен.
red_threshold также необязателен, если отсутствует, то в ответе `thresholded_images_cnt` = `total_images_cnt`
В этом хэндлере будет происходить простой select-запрос из таблицы _red_stats_table_ по индексам.

`POST red_stats_url/image_event`
С телом 
```
{
  "user_id": <user_id>,
  "red_percentage": <0..1>
}
```
В эту ручку сервис RED будет отправлять данные о том, что пользователь user_id прислал изображение с процентом красного red_percentage.
Хэндлер RED_STATS будет записывать эти данные в _red_stats_table_. Затем проверять, есть ли указанный user_id в _subscription_table_.
Если есть и порог этого изображения выше, чем заданный, то ставить таску в асинхронную очередь задач(например Celery).
Очередь задач, в свою очередь, будет делать запрос вида `POST callback_url` с заголовками `callback_headers` и телом `{"red_percentage": <Пришедшее значение>}`

Если таблица с пользователями вырастет очень сильно, то здесь могут случиться просадки в момент определения, нужно ли слать оповещение. В таком случае, эту логику можно перенести в ту же асинхронную таску.


### Потенциальные проблемы
В какой-то момент можем упереться в базу с таблицей _red_stats_table_. 
Однако при заданной нагрузке произойдет это не скоро:
Размер одной записи ~50b, поэтому в день таблица будет увеличиваться на 2Gb. 
Судя по интернетам, постгрес выдерживает таблицы до 4Tb, этого хватит на 5.5 лет работы сервиса.
В случае чего, можно применить шардирование по user_id или архивирование по timestamp. В последнем случае нужен будет отдельный индекс на эту колонку.
